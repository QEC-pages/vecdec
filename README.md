# vecdec - vectorized decoder and LER estimator

## Overview 

The program can do several kinds of calculations depending on the value of the
`mode` command-line argument:

- `mode=0` Run the built-in vectorized decoder using the error data generated by
  the program itself or externally generated (e.g., using `Stim`).  See the
  [Vectorized decoder](#vectorized-decoder) Section.
- `mode=1` Currently unsupported; is reserved for BP decoder.
- `mode=2` Estimate logical error rate by enumerating most likely errors.  See
  the [LER estimator](#ler-estimator) Section.
  
In any mode, the program requires a pre-computed Detector Error Model (DEM), see
the [Error model](#error-model) section.

For additional details, see the [section](#-all-command-line-arguments) on
command-line arguments, the source code in `vecdec/src` directory, and example
scripts in the `vecdec/examples` directory.


## Installation 

The program uses `m4ri` library for binary linear algebra.
To install this library on a Ubuntu system, run
    `sudo apt-get install libm4ri-dev`
    
To run scripts in `vecdec/examples` directory, you will need to install
command-line versions of [Stim](https://github.com/quantumlib/Stim) and
[PyMatching](https://github.com/oscarhiggott/PyMatching).
    
For compilation *help*, change to the (vecdec/src/) directory and just run w/o
arguments  
    `make`
Since the program  is experimental, I recommend compiling with  
    `make vecdec EXTRA=""`
This will enable additional integrity checks.

## Error model

A detector error model (DEM) is a collection of independent `events`, each of
which is characterized by a probability `p`, a list of affected syndrome bits,
and a list of affected codewords.  Can be created by `stim`, see shell scripts
in the (vecdec/examples/) directory.  Notice that `stim` cycles are not
supported in the DEM file.  Only the lines starting with `error` are used; the
`detector` and `shift_detectors` are silently ignored, as well as any comments.
Any other entry will trigger an error.

```
# An example DEM file created by `stim`
error(0.125) D0
error(0.125) D0 D1
error(0.125) D0 D2
error(0.125) D1 D3
error(0.125) D1 L0
error(0.125) D2 D4
error(0.125) D3 D5
error(0.125) D4 D6
error(0.125) D5 D7
detector(1, 0) D0
detector(3, 0) D1
shift_detectors(0, 1) 0
detector(1, 0) D2
detector(3, 0) D3
shift_detectors(0, 1) 0
detector(1, 0) D4
detector(3, 0) D5
detector(1, 1) D6
detector(3, 1) D7
```

## Vectorized decoder

This section describes operation with the command-line switch `mode=1`.

### How it works 

Given a binary vector `s` with detector events, the goal is to construct the
most likely binary vector `e` such that `H*e=s`.  The decoding is verified by
computing the vector of observable bits `L*e` and comparing it with the
corresponding result computed from the actual error.

The random errors and the corresponding detector/observable vectors can be
generated on the fly (for a given error model), or read from files in 01
format.

The program processes up to `nvec` syndrome vectors at a time.  The syndrome
columns are written as columns of a binary matrix `S`.  The original check
matrix `H` (extracted from the error model) is combined with `S`, to form
block-matrix `[H,S]`.  At each step, a column ordering `P` is randomly generated
(using values of event probabilities to help), the Gauss elimination is
performed on the rows of the combined matrix, creating the list of pivot columns
`[i0, i1, ...]`, with one entry per row.  Given the transformed syndrome column
`[s0, s1, ...]`, the output vector has values given by the list of pairs
`[(i0,s0), (i1,s1), ...]`.  The energy is calculated as the sum of LLRs for
non-zero bits in `e` and recorded, along with the sparse form of `e` if the
energy is small enough.

The program stops after a sufficient number of attempts is made, and compares
the values `L*e` for each found error `e` with the similar ones generated from
the original errors; any mismatch is a logical error.

### How to run it

The `suggested` number of syndrome vectors to generate and process is given by
`ntot`.  In reality, the number of rounds is calculated as $\lceil$ `ntot/nvec`
$\rceil$, where `nvec` is another command line argument (currently, the default
`nvec=16`, although one should probably use at least `1023` for efficiency).  In
each round, `nvec` different syndrome vectors will be generated and processed.
Ideally, `nvec` should be a factor `64`, since 64-bit integers are used to store
binary vectors internally.

The parameter `nfail`, when non-zero, will cause execution to stop after
accumulating a given number of logical errors.

The parameter `lerr`, when non-zero, specifies the maximum number of non-zero
error bits outside of the index set to try before generating a new permutation.
This is similar to OSD level.

Another important command-line parameter is `steps`.  It should be set to a
large number (experiment!) for decoding to be accurate, especially close to the
threshold.  The related parameter `swait` (if non-zero) specifies the number of
steps w/o any updates to any error vector to wait before terminating the cycle.

Use `debug=0` to suppress any output except for simulation results.  Use
`debug=1023` to output all possible debugging information (not all bits are used
at this time).

Use `fdem="filename"` (with or without quotes) or `fdem= "filename"` (with a
space) to specify the input file with the detector error model.

You may also want to set the names of the input files, e.g.,
using the command-line arguments 
    `fdet=dets.01 fobs=obs_flips.01`

## LER estimator

This section describes operation with the command-line switch `mode=2`.

Given the error model, i.e., the matrices $H$, $L$, and the vector of column
probability values $p_i$, the program tries to enumerate the likely binary
`codewords` $c$ such that $He=0$, $Le\neq0$, 
while the associate log-likelihood probability ratio (LLR) 
$\sum_i c_i \ln(1/p_i-1)$
is not too large. 

In fact, right now it just tries to find the single most likely codeword $c$ and
outputs an estimate of the corresponding contribution to the logical error
probability, $$\prod_{i\in \mathop{\rm supp}c} 2[ p_i(1-p_i)]^{1/2}.$$

Apart from `mode=2`, relevant command line arguments are `steps=`, `debug=`,
and, of course, `dem=`.

## All command-line arguments 

You can generate the list of supported command line arguments by running 
`vecdec --help`.

```bash
./src/vecdec:  vecdec - vectorized decoder and LER estimator
  usage: ./src/vecdec param=value [[param=value] ... ]
	 Command line arguments are processed in the order given.
	 Supported parameters:
	 --help	: give this help (also '-h' or just 'help')
	 fdem=[string]	: name of the input file with detector error model
	 fdet=[string]	: input file with detector events (01 format)
	 fobs=[string]	: file with observables (01 matching lines in fdet)
			 (space is OK in front of file name to enable shell completion)
	 steps=[integer]	: num of random window decoding steps (default: 1)
	 lerr =[integer]	: local search level after gauss (0, no search)
	 swait=[integer]	: steps w/o new errors to stop (0, do not stop)
	 nvec =[integer]	: max vector size for decoding (default: 16)
			 (list size in distance or energy calculations)
	 ntot =[integer]	: total syndromes to generate (default: 1)
	 nfail=[integer]	: total fails to terminate (0, do not terminate)
	 seed= [integer]	: RNG seed or use time(NULL) if 0 (default)
	 mode= [integer]	: operation mode (default: 0)
		* 0: use basic decoder; read events from file if spec'd
		* 1: (reserved for BP)
		* 2: generate most likely fault vectors, estimate Prob(Fail)
	 debug=[integer]	: bitmap for aux information to output (default: 1)
		*   0: clear the entire debug bitmap to 0.
		*   1: output misc general info (on by default)
		*   2: output matrices for verification
	 See program documentation for input file syntax.
	 Multiple `debug` parameters are XOR combined except for 0.
	 Use debug=0 as the 1st argument to suppress all debug messages.
```

## Libraries 

The program uses `m4ri` library for binary linear algebra.

## Future

Eventually, the program will be able to use more efficient decoders, e.g.,
belief propagation.

